//R√©cup√©ration des fonctions pour cr√©er des boutons
const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
//R√©cup du logger
const logger = require('./../modules/logger');
//R√©cup du cr√©ateur d'embed
const emb = require('./../modules/embeds');
//R√©cup des requ√™tes SQL
const sql = require('./../sql/radios');

//Boutons de regen radios
const radioBtns = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setLabel('LSMS').setCustomId('serviceRegenLSMS').setStyle(ButtonStyle.Danger).setEmoji('1124910934922625104').setDisabled(false),
    new ButtonBuilder().setLabel('FDO').setCustomId('serviceRegenFDO').setStyle(ButtonStyle.Primary).setEmoji('1124920279559327824').setDisabled(false),
    new ButtonBuilder().setLabel('BCMS').setCustomId('serviceRegenBCMS').setStyle(ButtonStyle.Success).setEmoji('1124910870695256106').setDisabled(false),
    new ButtonBuilder().setLabel('Event').setCustomId('serviceRegenEvent').setStyle(ButtonStyle.Secondary).setEmoji('1121278617960329257').setDisabled(false),
    new ButtonBuilder().setCustomId('serviceRadioReset').setStyle(ButtonStyle.Secondary).setEmoji('1128896218672681090')
);
//Boutons de gestion du service
const btns = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setLabel('Service').setCustomId('serviceSwitch').setStyle(ButtonStyle.Danger),
    new ButtonBuilder().setLabel('Dispatch').setCustomId('serviceDispatch').setStyle(ButtonStyle.Primary),
    new ButtonBuilder().setLabel('A√Øe la t√™te').setCustomId('serviceSwitchOff').setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId('serviceManage').setStyle(ButtonStyle.Secondary).setEmoji('1128896218672681090')
);

module.exports = {
    start: (client) => {
        //Boucle infinie pour auto-recr√©ation en cas de supression
        setInterval(async () => {
            //R√©cup√©ration du serveur Discord LSMS
            const guild = client.guilds.cache.get(process.env.IRIS_PRIVATE_GUILD_ID);
            //R√©cup√©ration du channel de service
            const chan = guild.channels.cache.get(process.env.IRIS_SERVICE_CHANNEL_ID);
            //R√©cup√©ration du channel des radios
            const radioChan = guild.channels.cache.get(process.env.IRIS_RADIO_CHANNEL_ID);
            //Refresh de tous les messages du channel et check si les messages sont bien pr√©sents
            const messages = await chan.messages.fetch();
            const found = await getMessages(messages, client);
            const radioMessages = await radioChan.messages.fetch();
            const radioFound = await getMessages(radioMessages, client);
            //Si pas pr√©sent recr√©ation du message
            if(!found) {
                //Base de l'embed
                const serviceEmb = emb.generate(null, null, `**Pour indiquer une prise/fin de service - Appuyez sur üî¥ \n\nPour prendre/rel√¢cher le dispatch - Appuyez sur üîµ \n\nPour indiquer un mal de t√™te - Appuyez sur ‚ö´**`, `#FF0000`, process.env.LSMS_LOGO_V2, null, `Gestion du service`, `https://cdn.discordapp.com/icons/${process.env.IRIS_PRIVATE_GUILD_ID}/${client.guilds.cache.get(process.env.IRIS_PRIVATE_GUILD_ID).icon}.webp`, null, null, null, false);
                //Envois
                await chan.send({ embeds: [serviceEmb], components: [btns] });
            }
            if(!radioFound) {
                //Base de l'embed
                const radioEmb = emb.generate(null, null, null, `#FF0000`, process.env.LSMS_LOGO_V2, null, `Gestion des radios`, `https://cdn.discordapp.com/icons/${process.env.IRIS_PRIVATE_GUILD_ID}/${client.guilds.cache.get(process.env.IRIS_PRIVATE_GUILD_ID).icon}.webp`, null, null, null, false);
                //Radios
                var freqLSMS = await sql.getRadio('lsms');
                freqLSMS = freqLSMS[0].radiofreq;
                var freqFDO = await sql.getRadio('fdo');
                freqFDO = freqFDO[0].radiofreq;
                radioEmb.addFields([
                    {
                        name: `üíâ Radio LSMS`,
                        value: freqLSMS,
                        inline: true
                    },
                    {
                        name: `üëÆ Radio FDO`,
                        value: freqFDO,
                        inline: true
                    }
                ]);
                //Check de si les radios optionnelles doivent √™tre affich√©es
                var genBCMS = await sql.isRadioDisplayed('bcms');
                genBCMS = genBCMS[0].displayed;
                var genEvent = await sql.isRadioDisplayed('event');
                genEvent = genEvent[0].displayed;
                var freqBCMS = await sql.getRadio('bcms');
                freqBCMS = freqBCMS[0].radiofreq;
                var freqEvent = await sql.getRadio('event');
                freqEvent = freqEvent[0].radiofreq;
                if(genBCMS == '1' && genEvent == '0') {
                    radioEmb.addFields([
                        {
                            name: `\u200b`,
                            value: `\u200b`,
                            inline: true
                        },
                        {
                            name: `<:bcms:1128889752284844124> Radio BCMS`,
                            value: freqBCMS,
                            inline: true
                        },
                    ]);
                } else if(genBCMS == '0' && genEvent == '1') {
                    radioEmb.addFields([
                        {
                            name: `\u200b`,
                            value: `\u200b`,
                            inline: true
                        },
                        {
                            name: `üèÜ Radio Event`,
                            value: freqEvent,
                            inline: true
                        },
                    ]);
                } else if(genBCMS == '1' && genEvent == '1') {
                    radioEmb.addFields([
                        {
                            name: `\u200b`,
                            value: `\u200b`,
                            inline: true
                        },
                        {
                            name: `<:bcms:1128889752284844124> Radio BCMS`,
                            value: freqBCMS,
                            inline: true
                        },
                        {
                            name: `üèÜ Radio Event`,
                            value: freqEvent,
                            inline: true
                        },
                        {
                            name: `\u200b`,
                            value: `\u200b`,
                            inline: true
                        }
                    ]);
                }
                //Envois
                await radioChan.send({ embeds: [radioEmb], components: [radioBtns] });
            }
        }, 1000);
    },
    resetRadios: async (radio, client, interaction) => {
        //R√©cup√©ration du serveur Discord LSMS
        const guild = client.guilds.cache.get(process.env.IRIS_PRIVATE_GUILD_ID);
        //R√©cup√©ration du channel des radios
        const radioChan = guild.channels.cache.get(process.env.IRIS_RADIO_CHANNEL_ID);
        //Refresh de tous les messages du channel et check si message bien pr√©sent
        const messages = await radioChan.messages.fetch();
        const msg = await getMessages(messages, client);
        if(msg != false) {
            //Reset de l'embed
            const radioEmb = emb.generate(null, null, null, `#FF0000`, process.env.LSMS_LOGO_V2, null, `Gestion des radios`, `https://cdn.discordapp.com/icons/${process.env.IRIS_PRIVATE_GUILD_ID}/${client.guilds.cache.get(process.env.IRIS_PRIVATE_GUILD_ID).icon}.webp`, null, null, null, false);
            radioEmb.addFields([
                {
                    name: `üíâ Radio LSMS`,
                    value: `0.0`,
                    inline: true
                },
                {
                    name: `üëÆ Radio FDO`,
                    value: `0.0`,
                    inline: true
                }
            ]);
            //Reset des radios en DB
            await sql.setRadio('lsms', '0.0');
            await sql.setRadio('bcms', '0.0');
            await sql.updatedRadioDisplay('bcms', '0');
            await sql.setRadio('event', '0.0');
            await sql.updatedRadioDisplay('event', '0');
            //Envois du message
            await msg.edit({ embeds: [radioEmb], components: [radioBtns] });
            await interaction.deferUpdate();
        }
    },
    
    //Fonction s√©par√©e pour attendre la fin du check des messages un par un
    getMessages: (messages, client) => {
        return getMessages(messages, client);
    }
}

//Fonction s√©par√©e pour attendre la fin du check des messages un par un
function getMessages(messages, client) {
    return new Promise((resolve, reject) => {
        messages.forEach(msg => {
            if(msg.author.username == client.user.username && msg.embeds[0] != null) {
                if(msg.embeds[0].author.name == 'Gestion du service' || msg.embeds[0].author.name == 'Gestion des radios') {
                    resolve(msg);
                    return;
                }
            }
        });
        resolve(false);
    });
}